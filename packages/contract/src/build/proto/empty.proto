syntax = "proto3";

package empty;

import "koinos/options.proto"; 

message str {
   string value = 1;
}

message uint64 {
   uint64 value = 1;
}

message list_args {
   bytes start = 1 [(koinos.btype) = ADDRESS];
   int32 limit = 2;
   direction direction = 3;
}

message addresses {
   repeated bytes accounts = 1 [(koinos.btype) = ADDRESS];
}

enum direction {
   ascending = 0;
   descending = 1;
}

message get_vault_args {
   bytes owner = 1 [(koinos.btype) = ADDRESS];
}

message vaultbalances {
   uint64 koin = 1 [jstype = JS_STRING];
   uint64 eth = 2 [jstype = JS_STRING];
   uint64 btc = 3 [jstype = JS_STRING];
   uint64 kas = 4 [jstype = JS_STRING];
   uint64 kusdgold = 5 [jstype = JS_STRING];
   uint64 kusdsilver = 6 [jstype = JS_STRING];
}

message deposit_args {
   bytes account = 1 [(koinos.btype) = ADDRESS];
   uint32 collateral = 2;
   uint64 amount = 3 [jstype = JS_STRING];
   uint32 fee = 4;
   bytes fee_address = 5 [(koinos.btype) = ADDRESS];
}

message mint_args {
   bytes account = 1 [(koinos.btype) = ADDRESS];
   uint32 type = 2;
   uint64 amount = 3 [jstype = JS_STRING];
}

message repay_args {
   bytes account = 1 [(koinos.btype) = ADDRESS];
   uint32 type = 2;
   uint64 amount = 3 [jstype = JS_STRING];
}

message withdraw_args {
   bytes account = 1 [(koinos.btype) = ADDRESS];
   uint32 collateral = 2;
   uint64 amount = 3 [jstype = JS_STRING];
}

message liquidate_args {
   bytes account = 1 [(koinos.btype) = ADDRESS];
   uint32 type = 2;
   bytes vault = 3 [(koinos.btype) = ADDRESS];
}



message ratio_args {
   
}

message ratio_result {
   string k_last = 1;
   uint64 token_a = 2 [jstype = JS_STRING];
   uint64 token_b = 3 [jstype = JS_STRING];
   uint64 block_time = 4 [jstype = JS_STRING];
}

message get_price_args {
  bytes token_address = 1 [(koinos.btype) = CONTRACT_ID];
}

message price_object {
  uint64 price = 1 [jstype = JS_STRING];
  uint64 timestamp = 2 [jstype = JS_STRING];
}
